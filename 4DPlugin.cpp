/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : cURL FTP
 #	author : miyako
 #	2017/12/13
 #
 # --------------------------------------------------------------------------------*/

#define CURLOPT_PROXY_AUTOPROXY 11111

#include "4DPluginAPI.h"
#include "4DPlugin.h"

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnStartup()
{
	curl_global_init(CURL_GLOBAL_DEFAULT);
}

void OnCloseProcess()
{
	if(IsProcessOnExit())
	{
		curl_global_cleanup();
	}
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
			// --- FTP

		case 1 :
			cURL_HTTP_Request(pResult, pParams);
			break;

	}
}

// -------------------------------------- FTP -------------------------------------

#pragma mark -

CURLcode curl_perform(CURLM *mcurl, CURL *curl, C_TEXT& Param3, C_TEXT& userInfo)
{
	CURLMcode mc = CURLM_OK; /* not used to abort */
	CURLcode result = CURLE_OK;
	
	curl_multi_add_handle(mcurl, curl);
	int running_handles = 0;
	
	long curl_timeout = 1000;
	curl_multi_timeout(mcurl, &curl_timeout);
	curl_timeout = (curl_timeout > 0) ? curl_timeout : 1000;
	curl_timeout = (curl_timeout > 1000) ? 1000 : curl_timeout;
	timeval tv;
	tv.tv_sec = curl_timeout / 1000;
	tv.tv_usec = (curl_timeout % 1000) * 1000;
	
	fd_set fdread;
	fd_set fdwrite;
	fd_set fdexcep;
	
	PA_Variable	params[4];
	
	PA_long32 method_id = PA_GetMethodID((PA_Unichar *)Param3.getUTF16StringPtr());
	
	if(method_id)
	{
		params[0] = PA_CreateVariable(eVK_Unistring);
		params[1] = PA_CreateVariable(eVK_Unistring);
		params[2] = PA_CreateVariable(eVK_Undefined);
		params[3] = PA_CreateVariable(eVK_Undefined);
		PA_SetUnistring((&(params[1].uValue.fString)),
										(PA_Unichar *)userInfo.getUTF16StringPtr());
	}else
	{
		params[0] = PA_CreateVariable(eVK_Unistring);
		params[1] = PA_CreateVariable(eVK_Boolean);
		params[2] = PA_CreateVariable(eVK_Unistring);
		params[3] = PA_CreateVariable(eVK_Unistring);
		PA_SetUnistring((&(params[0].uValue.fString)),
										(PA_Unichar *)Param3.getUTF16StringPtr());
		PA_SetUnistring((&(params[3].uValue.fString)),
										(PA_Unichar *)userInfo.getUTF16StringPtr());
	}
	
	do
	{
		
		FD_ZERO(&fdread);
		FD_ZERO(&fdwrite);
		FD_ZERO(&fdexcep);
		
		int maxfd = -1;
		mc = curl_multi_fdset(mcurl, &fdread, &fdwrite, &fdexcep, &maxfd);
		int rc = 0;
		if(maxfd == -1)
		{
			PA_PutProcessToSleep(PA_GetCurrentProcessNumber(), 6);
			rc = 0;
		}
		else
		{
			PA_YieldAbsolute();
			rc = select(maxfd+1, &fdread, &fdwrite, &fdexcep, &tv);
		}
		switch(rc) {
			case -1:
				/* select error */
				break;
			case 0:
			default:
				/* timeout or readable/writable sockets */
				mc = curl_multi_perform(mcurl, &running_handles);
				/* callback method */
			{
				
				if(Param3.getUTF16Length())
				{
					CUTF16String info;
					curl_get_info(curl, info);
					
					if(method_id)
					{
						PA_SetUnistring((&(params[0].uValue.fString)),
														(PA_Unichar *)info.c_str());
						
						PA_Variable statusCode = PA_ExecuteMethodByID(method_id, params, 2);
						if(PA_GetVariableKind(statusCode) == eVK_Boolean)
						{
							if(PA_GetBooleanVariable(statusCode))
							{
								/* abort */
								result = CURLE_ABORTED_BY_CALLBACK;
								goto curl_abort_transfer;
							}
						}
					}else
					{
						PA_SetUnistring((&(params[2].uValue.fString)),
														(PA_Unichar *)info.c_str());
						
						PA_SetBooleanVariable(&params[1], false);
						PA_ExecuteCommandByID(1007, params, 4);
						if(PA_GetBooleanVariable(params[1]))
						{
							/* abort */
							result = CURLE_ABORTED_BY_CALLBACK;
							goto curl_abort_transfer;
						}
					}
				}
				
				if(PA_IsProcessDying())
				{
					/* abort (runtime explorer, not debugger) */
					result = CURLE_ABORTED_BY_CALLBACK;
					goto curl_abort_transfer;
				}
				
			}
				break;
		}
		
	}while((running_handles != 0));
	
curl_abort_transfer:
	
	PA_ClearVariable(&params[0]);
	PA_ClearVariable(&params[1]);
	PA_ClearVariable(&params[2]);
	PA_ClearVariable(&params[3]);
	
	struct CURLMsg *m;
	int msgq = 0;
	m = curl_multi_info_read(mcurl, &msgq);
	if(m && (m->msg == CURLMSG_DONE))
	{
		result = m->data.result;
	}
	
	curl_multi_remove_handle(mcurl, curl);
	
	return result;
}

#pragma mark -

bool create_folder(path_t *absolute_path){
	
	bool success = false;
	
#if VERSIONMAC
	NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path);
	NSFileManager *fm = [[NSFileManager alloc]init];
	success = [fm createDirectoryAtPath:path
					withIntermediateDirectories:YES
													 attributes:nil
																error:NULL];
	[path release];
	[fm release];
#else
	success = SHCreateDirectory(NULL, (PCWSTR)absolute_path);
#endif
	
	return success;
}

void create_parent_folder(path_t *absolute_path){
#if VERSIONMAC
	NSString *filePath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path);
	absolute_path_t folderPath = absolute_path_t([[filePath stringByDeletingLastPathComponent]fileSystemRepresentation]);
	create_folder((path_t *)folderPath.c_str());
	[filePath release];
#else
	wchar_t	fDrive[_MAX_DRIVE],
	fDir[_MAX_DIR],
	fName[_MAX_FNAME],
	fExt[_MAX_EXT];
	_wsplitpath_s(absolute_path, fDrive, fDir, fName, fExt);
	absolute_path_t folderPath = fDrive;
	folderPath += fDir;
	create_folder((path_t *)folderPath.c_str());
#endif
}

#pragma mark download

size_t curl_write_function_for_path(void *buffer,
																		size_t size,
																		size_t nmemb,
																		path_ctx *ctx)
{
	size_t len = size * nmemb;

	if(ctx->useWildCard)
	{
		if(ctx->f)
		{
			fwrite(buffer, size, nmemb, ctx->f);
		}else
		{
			len = 0;
		}
	}else
	{
		create_parent_folder((path_t *)ctx->path);
		FILE *f = CPathOpen (ctx->path, ctx->shouldAppend ? CPathAppend : CPathCreate);
		ctx->shouldAppend = TRUE;
		
		if(f)
		{
			fwrite(buffer, size, nmemb, f);
			fclose(f);
		}else
		{
			len = 0;
		}
	}
	
	return len;
}

size_t curl_chunk_bgn_function(struct curl_fileinfo *finfo,
															 path_ctx *ctx,
															 int remains)
{
	absolute_path_t path = absolute_path_t(ctx->dir);
	
#if VERSIONMAC
	absolute_path_t filename = absolute_path_t(finfo->filename);
#else
	C_TEXT t;
	t.setUTF8String((const uint8_t *)finfo->filename, strlen(finfo->filename));
	absolute_path_t filename = (const wchar_t *)t.getUTF16StringPtr();
#endif
	
	if((finfo->filetype) == CURLFILETYPE_FILE)
	{
		ctx->path = path.append(filename).c_str();
		create_parent_folder((path_t *)ctx->path);
		ctx->f = CPathOpen (ctx->path, CPathCreate);
		if(!ctx->f)
		{
			return CURL_CHUNK_BGN_FUNC_FAIL;
		}
	}
	
	return CURL_CHUNK_BGN_FUNC_OK;
}

size_t curl_chunk_end_function(path_ctx *ctx)
{
	if(ctx->f)
	{
		fclose(ctx->f);
		ctx->f = NULL;
	}
	
	return CURL_CHUNK_END_FUNC_OK;
}

void cURL_FTP_Receive(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT Param3;
	C_TEXT Param4;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	
	CURL *curl = curl_easy_init();
	CURLM *mcurl = curl_multi_init();
	
	C_TEXT userInfo; /* PRIVATE */
	CUTF8String path;
	
	curl_set_options(curl, Param1, userInfo, path);
	
	path_ctx ctx;
	ctx.f = NULL;
	ctx.useWildCard = FALSE;
	ctx.shouldAppend = FALSE;
	ctx.path = NULL;
	ctx.dir = NULL;
	
	CPathString local_path;
	
#if VERSIONMAC
	Param2.copyPath(&local_path);
	remove_trailing_separator(local_path);
	ctx.path = (const char *)local_path.c_str();
#else
	local_path = Param2.getUTF16StringPtr();
	remove_trailing_separator(local_path);
	ctx.path = (const wchar_t *)local_path.c_str();
#endif
	
	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
	curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
	curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
	
	if(Param3.getIntValue())
	{
		ctx.useWildCard =TRUE;
		curl_easy_setopt(curl, CURLOPT_WILDCARDMATCH, 1L);
		curl_easy_setopt(curl, CURLOPT_CHUNK_BGN_FUNCTION, curl_chunk_bgn_function);
		curl_easy_setopt(curl, CURLOPT_CHUNK_END_FUNCTION, curl_chunk_end_function);
		curl_easy_setopt(curl, CURLOPT_CHUNK_DATA, &ctx);
#if VERSIONMAC
		local_path += folder_separator;
		ctx.dir = (const char *)local_path.c_str();
#else
		local_path += folder_separator;
		ctx.dir = (const wchar_t *)local_path.c_str();
#endif
	}
	
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, &ctx);
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_function_for_path);

	CURLcode result = curl_perform(mcurl, curl, Param4, userInfo);

	curl_easy_cleanup(curl);
	curl_multi_cleanup(mcurl);
	
	returnValue.setIntValue(result);
	returnValue.setReturn(pResult);
}

#pragma mark upload

size_t curl_read_function_for_path(void *buffer,
																		size_t size,
																		size_t nmemb,
																		path_ctx *ctx)
{
	size_t len = size * nmemb;
	FILE *f;
	
	f = CPathOpen (ctx->path, CPathRead);
	
	if(f)
	{
		fseek(f, ctx->pos, SEEK_SET);
		len = fread(buffer, size, nmemb, f);
		ctx->pos += len;
		fclose(f);
	}else
	{
		len = 0;/* file not found */
	}
	
	return len;
}

void cURL_FTP_Send(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT Param3;
	C_TEXT Param4;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	
	CURL *curl = curl_easy_init();
	CURLM *mcurl = curl_multi_init();
	
	C_TEXT userInfo; /* PRIVATE */
	CUTF8String path;
	
	curl_set_options(curl, Param1, userInfo, path);
	
	path_ctx ctx;
	ctx.pos = 0L;
	
	CPathString local_path;
#if VERSIONMAC
	Param2.copyPath(&local_path);
	ctx.path = (const char *)local_path.c_str();
#else
	local_path = Param2.getUTF16StringPtr();
	ctx.path = (const wchar_t *)local_path.c_str();
#endif
	
	/* file size */
	curl_off_t fileSize = 0L;
	FILE *f = CPathOpen (ctx.path, CPathRead);
	if(f)
	{
		fseek(f, 0L, SEEK_END);
		fileSize = (curl_off_t)ftell(f);
		fclose(f);
		
		if(fileSize != -1L)
		{
			curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE_LARGE, fileSize);
		}
		
		if(Param3.getIntValue())
		{
			curl_easy_setopt(curl, CURLOPT_FTP_CREATE_MISSING_DIRS, CURLFTP_CREATE_DIR_RETRY);
		}
		
		curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);
		
		curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
		curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
		curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
		
		curl_easy_setopt(curl, CURLOPT_READDATA, &ctx);
		curl_easy_setopt(curl, CURLOPT_READFUNCTION, curl_read_function_for_path);
		
		returnValue.setIntValue(curl_perform(mcurl, curl, Param4, userInfo));
	}

	curl_easy_cleanup(curl);
	curl_multi_cleanup(mcurl);
	
	returnValue.setReturn(pResult);
}

#pragma mark -



#pragma mark JSON

void json_wconv(const wchar_t *value, CUTF16String *u16)
{
	size_t wlen = wcslen(value);
	
#if VERSIONWIN
	*u16 = CUTF16String((const PA_Unichar *)value, wlen);
#else
	uint32_t dataSize = (uint32_t)((wlen * sizeof(wchar_t))+ sizeof(PA_Unichar));
	std::vector<char> buf(dataSize);
	//returns byte size in toString (in this case, need to /2 to get characters)
	uint32_t len = PA_ConvertCharsetToCharset((char *)value,
																						(PA_long32)(wlen * sizeof(wchar_t)),
																						eVTC_UTF_32,
																						(char *)&buf[0],
																						dataSize,
																						eVTC_UTF_16);
	*u16 = CUTF16String((const PA_Unichar *)&buf[0], len/sizeof(PA_Unichar));
#endif
}

void json_wconv(const wchar_t *value, CUTF8String *u8)
{
	C_TEXT t;
	size_t wlen = wcslen(value);
	
#if VERSIONWIN
	t.setUTF16String((const PA_Unichar *)value, wlen);
#else
	uint32_t dataSize = (uint32_t)((wlen * sizeof(wchar_t))+ sizeof(PA_Unichar));
	std::vector<char> buf(dataSize);
	//returns byte size in toString (in this case, need to /2 to get characters)
	uint32_t len = PA_ConvertCharsetToCharset((char *)value,
																						(PA_long32)(wlen * sizeof(wchar_t)),
																						eVTC_UTF_32,
																						(char *)&buf[0],
																						dataSize,
																						eVTC_UTF_16);
	t.setUTF16String((const PA_Unichar *)&buf[0], len/sizeof(PA_Unichar));
#endif
	t.copyUTF8String(u8);
}

void json_wconv(const char *value, std::wstring &u32)
{
	if((value) && strlen(value))
	{
		C_TEXT t;
		CUTF8String u8 = CUTF8String((const uint8_t *)value);
		
		t.setUTF8String(&u8);
		
#if VERSIONWIN
		u32 = std::wstring((wchar_t *)t.getUTF16StringPtr());
#else
		uint32_t dataSize = (t.getUTF16Length() * sizeof(wchar_t))+ sizeof(wchar_t);
		std::vector<char> buf(dataSize);
		
		PA_ConvertCharsetToCharset((char *)t.getUTF16StringPtr(),
															 t.getUTF16Length() * sizeof(PA_Unichar),
															 eVTC_UTF_16,
															 (char *)&buf[0],
															 dataSize,
															 eVTC_UTF_32);
		
		u32 = std::wstring((wchar_t *)&buf[0]);
#endif
	}else
	{
		u32 = L"";
	}
	
}

void json_push_back_s(JSONNODE *n, const char *value)
{
	if(n)
	{
		if(value)
		{
			std::wstring w32;
			json_wconv(value, w32);
			
			JSONNODE *e = json_new(JSON_STRING);
			json_set_a(e, w32.c_str());
			json_push_back(n, e);
		}else
		{
			JSONNODE *e = json_new(JSON_STRING);
			json_nullify(e);
			json_push_back(n, e);
		}
	}
	
}

void json_set_s(JSONNODE *n, const char *value)
{
	if(n)
	{
		if(value)
		{
			std::wstring w32;
			json_wconv(value, w32);
			json_set_a(n, w32.c_str());
		}else
		{
			json_nullify(n);
		}
	}
}

void json_set_s_for_key(JSONNODE *n, json_char *key, const char *value)
{
	if(n)
	{
		if(value)
		{
			std::wstring w32;
			json_wconv(value, w32);
			
			JSONNODE *e = json_get(n, key);
			if(e)
			{
				json_set_a(e, w32.c_str());//over-write existing value
			}else
			{
				json_push_back(n, json_new_a(key, w32.c_str()));
			}
			
		}else
		{
			JSONNODE *e = json_get(n, key);
			if(e)
			{
				json_nullify(e);//over-write existing value
			}else
			{
				JSONNODE *node = json_new_a(key, L"");
				json_nullify(node);
				json_push_back(n, node);
			}
		}
	}
}

void json_set_b_for_key(JSONNODE *n, json_char *key, json_bool_t value)
{
	if(n)
	{
		JSONNODE *e = json_get(n, key);
		if(e)
		{
			json_set_b(e, value);//over-write existing value
		}else
		{
			json_push_back(n, json_new_b(key, value));
		}
	}
}

void json_set_i_for_key(JSONNODE *n, json_char *key, json_int_t value)
{
	if(n)
	{
		JSONNODE *e = json_get(n, key);
		if(e)
		{
			json_set_i(e, value);//over-write existing value
		}else
		{
			json_push_back(n, json_new_i(key, value));
		}
	}
}

void json_stringify(JSONNODE *json, CUTF16String &t, BOOL pretty)
{
	json_char *json_string = pretty ? json_write_formatted(json) : json_write(json);
	std::wstring wstr = std::wstring(json_string);
#if VERSIONWIN
	t = CUTF16String((const PA_Unichar *)wstr.c_str(), (uint32_t)wstr.length());
#else
	uint32_t dataSize = (uint32_t)((wstr.length() * sizeof(wchar_t))+ sizeof(PA_Unichar));
	std::vector<char> buf(dataSize);
	//returns byte size in toString (in this case, need to /2 to get characters)
	uint32_t len = PA_ConvertCharsetToCharset((char *)wstr.c_str(),
																						(PA_long32)(wstr.length() * sizeof(wchar_t)),
																						eVTC_UTF_32,
																						(char *)&buf[0],
																						dataSize,
																						eVTC_UTF_16);
	t = CUTF16String((const PA_Unichar *)&buf[0], len/sizeof(PA_Unichar));
#endif
	json_free(json_string);
}

#pragma mark JSON cURL

CURLoption json_get_curl_option_name(JSONNODE *n)
{
	CURLoption v = (CURLoption)0;
	
	if(n)
	{
		v = (CURLoption)json_as_int(n);
		
		json_char *name = json_name(n);
		
		if (name)
		{
			std::wstring s = std::wstring((const wchar_t *)name);
            /* general */
			if (s.compare(L"VERBOSE") == 0)
			{
				v = CURLOPT_VERBOSE;goto json_get_curl_option_exit;
			}
			if (s.compare(L"URL") == 0)
			{
				v = CURLOPT_URL;goto json_get_curl_option_exit;
			}
			if (s.compare(L"USERNAME") == 0)
			{
				v = CURLOPT_USERNAME;goto json_get_curl_option_exit;
			}
			if (s.compare(L"PASSWORD") == 0)
			{
				v = CURLOPT_PASSWORD;goto json_get_curl_option_exit;
			}
            if (s.compare(L"PRIVATE") == 0)
            {
                v = CURLOPT_PRIVATE;goto json_get_curl_option_exit;
            }
            /* TLS */
            if (s.compare(L"USE_SSL") == 0)
            {
                v = CURLOPT_USE_SSL;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSL_VERIFYHOST") == 0)
            {
                v = CURLOPT_SSL_VERIFYHOST;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSL_VERIFYPEER") == 0)
            {
                v = CURLOPT_SSL_VERIFYPEER;goto json_get_curl_option_exit;
            }
            if (s.compare(L"CAINFO") == 0)
            {
                v = CURLOPT_CAINFO;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSLCERT") == 0)
            {
                v = CURLOPT_SSLCERT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSLKEY") == 0)
            {
                v = CURLOPT_SSLKEY;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSLCERTTYPE") == 0)
            {
                v = CURLOPT_SSLCERTTYPE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSLKEYTYPE") == 0)
            {
                v = CURLOPT_SSLKEYTYPE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"TLSAUTH_TYPE") == 0)
            {
                v = CURLOPT_TLSAUTH_TYPE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"TLSAUTH_USERNAME") == 0)
            {
                v = CURLOPT_TLSAUTH_USERNAME;goto json_get_curl_option_exit;
            }
            if (s.compare(L"TLSAUTH_PASSWORD") == 0)
            {
                v = CURLOPT_TLSAUTH_PASSWORD;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSL_SESSIONID_CACHE") == 0)
            {
                v = CURLOPT_SSL_SESSIONID_CACHE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSL_CIPHER_LIST") == 0)
            {
                v = CURLOPT_SSL_CIPHER_LIST;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PINNEDPUBLICKEY") == 0)
            {
                v = CURLOPT_PINNEDPUBLICKEY;goto json_get_curl_option_exit;
            }
            if (s.compare(L"ISSUERCERT") == 0)
            {
                v = CURLOPT_ISSUERCERT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"CRLFILE") == 0)
            {
                v = CURLOPT_CRLFILE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSL_ENABLE_ALPN") == 0)
            {
                v = CURLOPT_SSL_ENABLE_ALPN;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSL_ENABLE_NPN") == 0)
            {
                v = CURLOPT_SSL_ENABLE_NPN;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSL_FALSESTART") == 0)
            {
                v = CURLOPT_SSL_FALSESTART;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSLVERSION") == 0)
            {
                v = CURLOPT_SSLVERSION;goto json_get_curl_option_exit;
            }
            if (s.compare(L"VERIFYSTATUS") == 0)
            {
                v = CURLOPT_SSL_VERIFYSTATUS;goto json_get_curl_option_exit;
            }
            if (s.compare(L"KEYPASSWD") == 0)
            {
                v = CURLOPT_KEYPASSWD;goto json_get_curl_option_exit;
            }
            /* proxy */
            if (s.compare(L"PROXY") == 0)
            {
                v = CURLOPT_PROXY;goto json_get_curl_option_exit;
            }
            if (s.compare(L"NOPROXY") == 0)
            {
                v = CURLOPT_NOPROXY;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXYPORT") == 0)
            {
                v = CURLOPT_PROXYPORT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXYTYPE") == 0)
            {
                v = CURLOPT_PROXYTYPE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXYUSERNAME") == 0)
            {
                v = CURLOPT_PROXYUSERNAME;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXYPASSWORD") == 0)
            {
                v = CURLOPT_PROXYPASSWORD;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_SERVICE_NAME") == 0)
            {
                v = CURLOPT_PROXY_SERVICE_NAME;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_SSLCERT") == 0)
            {
                v = CURLOPT_PROXY_SSLCERT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_SSLKEY") == 0)
            {
                v = CURLOPT_PROXY_SSLKEY;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_SSLCERTTYPE") == 0)
            {
                v = CURLOPT_PROXY_SSLCERTTYPE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_SSLKEYTYPE") == 0)
            {
                v = CURLOPT_PROXY_SSLKEYTYPE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXYAUTH") == 0)
            {
                v = CURLOPT_PROXYAUTH;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_TLSAUTH_USERNAME") == 0)
            {
                v = CURLOPT_PROXY_TLSAUTH_USERNAME;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_TLSAUTH_PASSWORD") == 0)
            {
                v = CURLOPT_PROXY_TLSAUTH_PASSWORD;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_TLSAUTH_TYPE") == 0)
            {
                v = CURLOPT_PROXY_TLSAUTH_TYPE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_SSL_CIPHER_LIST") == 0)
            {
                v = CURLOPT_PROXY_SSL_CIPHER_LIST;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_PINNEDPUBLICKEY") == 0)
            {
                v = CURLOPT_PROXY_PINNEDPUBLICKEY;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_CAINFO") == 0)
            {
                v = CURLOPT_PROXY_CAINFO;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_CRLFILE") == 0)
            {
                v = CURLOPT_PROXY_CRLFILE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_SSL_VERIFYHOST") == 0)
            {
                v = CURLOPT_PROXY_SSL_VERIFYHOST;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_SSL_VERIFYPEER") == 0)
            {
                v = CURLOPT_PROXY_SSL_VERIFYPEER;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_KEYPASSWD") == 0)
            {
                v = CURLOPT_PROXY_KEYPASSWD;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_SSLVERSION") == 0)
            {
                v = CURLOPT_PROXY_SSLVERSION;goto json_get_curl_option_exit;
            }
            if (s.compare(L"AUTOPROXY") == 0)
            {
                v = CURLOPT_PROXY_AUTOPROXY;goto json_get_curl_option_exit;
            }
            /* limits */
            if (s.compare(L"CONNECTTIMEOUT") == 0)
            {
                v = CURLOPT_CONNECTTIMEOUT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"TIMEOUT") == 0)
            {
                v = CURLOPT_TIMEOUT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"LOW_SPEED_TIME") == 0)
            {
                v = CURLOPT_LOW_SPEED_TIME;goto json_get_curl_option_exit;
            }
            if (s.compare(L"LOW_SPEED_LIMIT") == 0)
            {
                v = CURLOPT_LOW_SPEED_LIMIT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"MAXREDIRS") == 0)
            {
                v = CURLOPT_MAXREDIRS;goto json_get_curl_option_exit;
            }
            if (s.compare(L"MAXFILESIZE") == 0)
            {
                v = CURLOPT_MAXFILESIZE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"TCP_KEEPIDLE") == 0)
            {
                v = CURLOPT_TCP_KEEPIDLE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"TCP_KEEPALIVE") == 0)
            {
                v = CURLOPT_TCP_KEEPALIVE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"TCP_KEEPINTVL") == 0)
            {
                v = CURLOPT_TCP_KEEPINTVL;goto json_get_curl_option_exit;
            }
            if (s.compare(L"DNS_CACHE_TIMEOUT") == 0)
            {
                v = CURLOPT_DNS_CACHE_TIMEOUT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"EXPECT_100_TIMEOUT_MS") == 0)
            {
                v = CURLOPT_EXPECT_100_TIMEOUT_MS;goto json_get_curl_option_exit;
            }
            /* HTTP */
            if (s.compare(L"UPLOAD") == 0)
            {
                v = CURLOPT_UPLOAD;goto json_get_curl_option_exit;
            }
            if (s.compare(L"NOBODY") == 0)
            {
                v = CURLOPT_NOBODY;goto json_get_curl_option_exit;
            }
            if (s.compare(L"HTTP_VERSION") == 0)
            {
                v = CURLOPT_HTTP_VERSION;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXYHEADER") == 0)
            {
                v = CURLOPT_PROXYHEADER;goto json_get_curl_option_exit;
            }
            if (s.compare(L"HTTPHEADER") == 0)
            {
                v = CURLOPT_HTTPHEADER;goto json_get_curl_option_exit;
            }
            if (s.compare(L"HEADEROPT") == 0)
            {
                v = CURLOPT_HEADEROPT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"AUTOREFERER") == 0)
            {
                v = CURLOPT_AUTOREFERER;goto json_get_curl_option_exit;
            }
            if (s.compare(L"ACCEPT_ENCODING") == 0)
            {
                v = CURLOPT_ACCEPT_ENCODING;goto json_get_curl_option_exit;
            }
            if (s.compare(L"FOLLOWLOCATION") == 0)
            {
                v = CURLOPT_FOLLOWLOCATION;goto json_get_curl_option_exit;
            }
            if (s.compare(L"UNRESTRICTED_AUTH") == 0)
            {
                v = CURLOPT_UNRESTRICTED_AUTH;goto json_get_curl_option_exit;
            }
            if (s.compare(L"REFERER") == 0)
            {
                v = CURLOPT_REFERER;goto json_get_curl_option_exit;
            }
            if (s.compare(L"USERAGENT") == 0)
            {
                v = CURLOPT_USERAGENT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"HTTP200ALIASES") == 0)
            {
                v = CURLOPT_HTTP200ALIASES;goto json_get_curl_option_exit;
            }
            if (s.compare(L"COOKIE") == 0)
            {
                v = CURLOPT_COOKIE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"COOKIEFILE") == 0)
            {
                v = CURLOPT_COOKIEFILE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"COOKIEJAR") == 0)
            {
                v = CURLOPT_COOKIEJAR;goto json_get_curl_option_exit;
            }
            if (s.compare(L"COOKIESESSION") == 0)
            {
                v = CURLOPT_COOKIESESSION;goto json_get_curl_option_exit;
            }
            if (s.compare(L"COOKIELIST") == 0)
            {
                v = CURLOPT_COOKIELIST;goto json_get_curl_option_exit;
            }
            if (s.compare(L"REQUEST_TARGET") == 0)
            {
                v = CURLOPT_REQUEST_TARGET;goto json_get_curl_option_exit;
            }
            if (s.compare(L"IGNORE_CONTENT_LENGTH") == 0)
            {
                v = CURLOPT_IGNORE_CONTENT_LENGTH;goto json_get_curl_option_exit;
            }
            if (s.compare(L"CONTENT_DECODING") == 0)
            {
                v = CURLOPT_HTTP_CONTENT_DECODING;goto json_get_curl_option_exit;
            }
            if (s.compare(L"TRANSFER_ENCODING") == 0)
            {
                v = CURLOPT_TRANSFER_ENCODING;goto json_get_curl_option_exit;
            }
            if (s.compare(L"TRANSFER_DECODING") == 0)
            {
                v = CURLOPT_HTTP_TRANSFER_DECODING;goto json_get_curl_option_exit;
            }
            if (s.compare(L"RANGE") == 0)
            {
                v = CURLOPT_RANGE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"RESUME_FROM") == 0)
            {
                v = CURLOPT_RESUME_FROM;goto json_get_curl_option_exit;
            }
            if (s.compare(L"RESUME_FROM_LARGE") == 0)
            {
                v = CURLOPT_RESUME_FROM_LARGE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"CUSTOMREQUEST") == 0)
            {
                v = CURLOPT_CUSTOMREQUEST;goto json_get_curl_option_exit;
            }
            if (s.compare(L"HTTPAUTH") == 0)
            {
                v = CURLOPT_HTTPAUTH;goto json_get_curl_option_exit;
            }
            
		json_get_curl_option_exit:
			json_free(name);
		}
	}
	
	return v;
}

void json_get_curl_option_m(CURL *curl, CURLoption option, JSONNODE *n)
{
	if(n)
	{
		json_int_t v =  json_as_int(n);
		
		json_char *value = json_as_string(n);
		
		if(value)
		{
			std::wstring s = std::wstring((const wchar_t *)value);
            
            if (s.compare(L"BASIC") != std::string::npos)
            {
                v = v|CURLAUTH_BASIC;
            }
            if (s.compare(L"DIGEST_IE") != std::string::npos)
            {
                v = v|CURLAUTH_DIGEST_IE;
            }
            if (s.compare(L"DIGEST") != std::string::npos)
            {
                v = v|CURLAUTH_DIGEST;
            }
            if (s.compare(L"NEGOTIATE") != std::string::npos)
            {
                v = v|CURLAUTH_NEGOTIATE;
            }
            if (s.compare(L"NTLM_WB") != std::string::npos)
            {
                v = v|CURLAUTH_NTLM_WB;
            }
            if (s.compare(L"NTLM") != std::string::npos)
            {
                v = v|CURLAUTH_NTLM;
            }
            if (s.compare(L"ANY") != std::string::npos)
            {
                v = v|CURLAUTH_ANY;
            }
            if (s.compare(L"ANYSAFE") != std::string::npos)
            {
                v = v|CURLAUTH_ANYSAFE;
            }
			json_free(value);
		}
		
		
		curl_easy_setopt(curl, option, value);
	}
}

void json_get_curl_option_c(CURL *curl, CURLoption option, JSONNODE *n)
{
	if(n)
	{
		json_int_t value = json_get_curl_option_value(n);
		curl_easy_setopt(curl, option, value);
	}
}

void json_get_curl_option_i(CURL *curl, CURLoption option, JSONNODE *n)
{
	if(n)
	{
		json_int_t value = json_as_int(n);
		curl_easy_setopt(curl, option, value);
	}
}

void json_get_curl_option_p(CURL *curl, CURLoption option, JSONNODE *n)
{
	if(n)
	{
		json_char *value = json_as_string(n);
		
		if(value)
		{
			CUTF8String u;
			json_wconv(value, &u);
#if VERSIONMAC
			/* hfs to posix */
			C_TEXT t;
			t.setUTF8String(&u);
			t.copyPath(&u);
#endif
			curl_easy_setopt(curl, option, u.c_str());
			json_free(value);
		}
	}
}

void json_get_curl_option_s(CURL *curl, CURLoption option, JSONNODE *n, CUTF8String& path)
{
	if(n)
	{
		json_char *value = json_as_string(n);
		
		if(value)
		{
			CUTF8String u;
			json_wconv(value, &u);
			curl_easy_setopt(curl, option, u.c_str());
			if(option == CURLOPT_URL)
			{
				size_t pos = u.find((const uint8_t *)"://");
				if(pos != std::string::npos)
				{
					u = u.substr(pos + 4);//strlen("://")++
				}
				pos = u.find((const uint8_t *)"/");
				if(pos != std::string::npos)
				{
					path = u.substr(pos + 1);//++
				}
			}
			json_free(value);
		}
	}
}

long json_get_curl_option_value(JSONNODE *n)
{
	long v = json_as_int(n);
	
	json_char *value = json_as_string(n);
	
	if(value)
	{
		std::wstring s = std::wstring((const wchar_t *)value);

		if (s.compare(L"USESSL_NONE") == 0)
		{
			v = CURLUSESSL_NONE;goto json_get_curl_option_value_exit;
		}
		if (s.compare(L"USESSL_TRY") == 0)
		{
			v = CURLUSESSL_TRY;goto json_get_curl_option_value_exit;
		}
		if (s.compare(L"USESSL_CONTROL") == 0)
		{
			v = CURLUSESSL_CONTROL;goto json_get_curl_option_value_exit;
		}
		if (s.compare(L"USESSL_ALL") == 0)
		{
			v = CURLUSESSL_ALL;goto json_get_curl_option_value_exit;
		}

        if (s.compare(L"DEFAULT") == 0) /* undocumented */
        {
            v = CURL_SSLVERSION_DEFAULT;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"SSLVERSION_TLSv1") == 0) /* undocumented */
        {
            v = CURL_SSLVERSION_TLSv1;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"SSLv2") == 0)
        {
            v = CURL_SSLVERSION_SSLv2;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"SSLv3") == 0)
        {
            v = CURL_SSLVERSION_SSLv3;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"TLSv1.0") == 0)
        {
            v = CURL_SSLVERSION_TLSv1_0;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"TLSv1.1") == 0)
        {
            v = CURL_SSLVERSION_TLSv1_1;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"TLSv1.2") == 0)
        {
            v = CURL_SSLVERSION_TLSv1_2;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"TLSv1.3") == 0)
        {
            v = CURL_SSLVERSION_TLSv1_3;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"SSLVERSION_MAX_DEFAULT") == 0) /* undocumented */
        {
            v = CURL_SSLVERSION_MAX_DEFAULT;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"SSLVERSION_MAX_TLSv1_0") == 0) /* undocumented */
        {
            v = CURL_SSLVERSION_MAX_TLSv1_0;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"SSLVERSION_MAX_TLSv1_1") == 0) /* undocumented */
        {
            v = CURL_SSLVERSION_MAX_TLSv1_1;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"SSLVERSION_MAX_TLSv1_2") == 0) /* undocumented */
        {
            v = CURL_SSLVERSION_MAX_TLSv1_2;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"SSLVERSION_MAX_TLSv1_3") == 0) /* undocumented */
        {
            v = CURL_SSLVERSION_MAX_TLSv1_3;goto json_get_curl_option_value_exit;
        }

        if (s.compare(L"NONE") == 0) /* undocumented */
        {
            v = CURL_HTTP_VERSION_NONE;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"1.0") == 0)
        {
            v = CURL_HTTP_VERSION_1_0;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"1.1") == 0)
        {
            v = CURL_HTTP_VERSION_1_1;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"2") == 0)
        {
            v = CURL_HTTP_VERSION_2;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"2_TLS") == 0)
        {
            v = CURL_HTTP_VERSION_2TLS;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"2_PRIOR_KNOWLEDGE") == 0)
        {
            v = CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE;goto json_get_curl_option_value_exit;
        }

        if (s.compare(L"UNIFIED") == 0)
        {
            v = CURLHEADER_UNIFIED;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"SEPARATE") == 0)
        {
            v = CURLHEADER_SEPARATE;goto json_get_curl_option_value_exit;
        }
        
	json_get_curl_option_value_exit:
		json_free(value);
	}
	
	return v;
}

#pragma mark -

void curl_set_options(CURL *curl, C_TEXT& Param1, C_TEXT& userInfo, CUTF8String& path)
{
	CUTF8String Param1_u8;
	Param1.copyUTF8String(&Param1_u8);
	std::wstring Param1_option;
	json_wconv((const char *)Param1_u8.c_str(), Param1_option);
	JSONNODE *option = json_parse(Param1_option.c_str());
	if(option)
	{
		if (json_type(option) == JSON_NODE)
		{
			JSONNODE_ITERATOR i = json_begin(option);
			while (i != json_end(option))
			{
				CURLoption curl_option = json_get_curl_option_name(*i);
				switch (curl_option)
				{
					case CURLOPT_PRIVATE:
					{
						json_char *value = json_as_string(*i);
						if(value)
						{
							CUTF8String u;
							json_wconv(value, &u);
							userInfo.setUTF8String(&u);
							json_free(value);
						}
					}
						break;
						
						/* char */
                    case CURLOPT_URL:
                    case CURLOPT_USERNAME:
					case CURLOPT_PASSWORD:
                    case CURLOPT_PROXY:
                    case CURLOPT_NOPROXY:
                    case CURLOPT_PROXYTYPE:
                    case CURLOPT_PROXYUSERNAME:
                    case CURLOPT_PROXYPASSWORD:
                    case CURLOPT_PROXY_SERVICE_NAME:
                    case CURLOPT_PROXY_SSLCERTTYPE:
                    case CURLOPT_PROXY_SSLKEYTYPE:
                    case CURLOPT_PROXY_TLSAUTH_USERNAME:
                    case CURLOPT_PROXY_TLSAUTH_PASSWORD:
                    case CURLOPT_PROXY_TLSAUTH_TYPE:
                    case CURLOPT_SSLCERTTYPE:
                    case CURLOPT_SSLKEYTYPE:
                    case CURLOPT_TLSAUTH_TYPE:
                    case CURLOPT_TLSAUTH_USERNAME:
                    case CURLOPT_TLSAUTH_PASSWORD:
                    case CURLOPT_PROXY_SSL_CIPHER_LIST:
                    case CURLOPT_SSL_CIPHER_LIST:
                    case CURLOPT_KEYPASSWD:
                    case CURLOPT_PROXY_KEYPASSWD:

						json_get_curl_option_s(curl, curl_option, *i, path);
						break;
						
						/* path */
					case CURLOPT_CAINFO:
                    case CURLOPT_PROXY_CAINFO:
                    case CURLOPT_CRLFILE:
                    case CURLOPT_PROXY_CRLFILE:
					case CURLOPT_COOKIEFILE:
                    case CURLOPT_COOKIEJAR:
                    case CURLOPT_NETRC_FILE:
                    case CURLOPT_SSLCERT:
                    case CURLOPT_SSLKEY:
                    case CURLOPT_PROXY_SSLCERT:
                    case CURLOPT_PROXY_SSLKEY:
                    case CURLOPT_PROXY_PINNEDPUBLICKEY:
                    case CURLOPT_PINNEDPUBLICKEY:
                    case CURLOPT_ISSUERCERT:
                        
						json_get_curl_option_p(curl, curl_option, *i);
						break;
						
						/* long */
					case CURLOPT_VERBOSE:
                    case CURLOPT_PROXYPORT:
                    case CURLOPT_SSL_VERIFYHOST:
                    case CURLOPT_SSL_VERIFYPEER:
                    case CURLOPT_SSL_SESSIONID_CACHE:
                    case CURLOPT_PROXY_SSL_VERIFYHOST:
                    case CURLOPT_PROXY_SSL_VERIFYPEER:
                    case CURLOPT_SSL_ENABLE_ALPN:
                    case CURLOPT_SSL_ENABLE_NPN:
                    case CURLOPT_SSL_FALSESTART:
                    case CURLOPT_SSL_VERIFYSTATUS:
                    case CURLOPT_CONNECTTIMEOUT:
                    case CURLOPT_TIMEOUT:
                    case CURLOPT_LOW_SPEED_TIME:
                    case CURLOPT_LOW_SPEED_LIMIT:
                    case CURLOPT_MAXREDIRS:
                    case CURLOPT_MAXFILESIZE:
                    case CURLOPT_TCP_KEEPIDLE:
                    case CURLOPT_TCP_KEEPALIVE:
                    case CURLOPT_TCP_KEEPINTVL:
                    case CURLOPT_DNS_CACHE_TIMEOUT:
                    case CURLOPT_EXPECT_100_TIMEOUT_MS:

						json_get_curl_option_i(curl, curl_option, *i);
						break;
						
						/* constant or long */
					case CURLOPT_USE_SSL:
                    case CURLOPT_PROXY_SSLVERSION:
                    case CURLOPT_SSLVERSION:
                    case CURLOPT_HTTP_VERSION:
                        
						json_get_curl_option_c(curl, curl_option, *i);
						break;
						
						/* constant bit mask or long */
					case CURLOPT_HTTPAUTH:
                    case CURLOPT_PROXYAUTH:
						json_get_curl_option_m(curl, curl_option, *i);
						break;
						
					default:
						break;
				}
				
				++i;
			}
			
		}
		json_delete(option);
	}
	
}

void curl_get_info(CURL *curl, CUTF16String& json)
{
	long responseCode, connectCode, fileTime, redirectCount, headerSize, requestSize, lastSocket;
	long sslVerifyResult, localPort, primaryPort, numConnects, osErrNo, httpAuthAvail, proxyAuthAvail;
	double totalTime, nameLookupTime, connectTime, appConnectTime, preTransferTime, startTransferTime, redirectTime;
	double sizeUpload, speedUpload, sizeDownload, speedDownload, contentLengthDownload, contentLengthUpload;
	long rtspClientCseq, rtspServerCseq, rtspCseqRecv, conditionUnmet;
	char *effectiveUrl = NULL;
	char *redirectUrl = NULL;
	char *contentType = NULL;
	char *ftpEntryPath = NULL;
	char *localIp = NULL;
	char *primaryIp = NULL;
	char *rtspSessionId = NULL;
	
	JSONNODE *info = json_new(JSON_NODE);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &conditionUnmet))
		json_set_i_for_key(info, L"conditionUnmet", conditionUnmet);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_UPLOAD, &contentLengthUpload))
		json_set_i_for_key(info, L"contentLengthUpload", contentLengthUpload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_CLIENT_CSEQ, &rtspClientCseq))
		json_set_i_for_key(info, L"rtspClientCseq", rtspClientCseq);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_SERVER_CSEQ, &rtspServerCseq))
		json_set_i_for_key(info, L"rtspServerCseq", rtspServerCseq);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_CSEQ_RECV, &rtspCseqRecv))
		json_set_i_for_key(info, L"rtspCseqRecv", rtspCseqRecv);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LASTSOCKET, &lastSocket))
		json_set_i_for_key(info, L"lastSocket", lastSocket);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT, &primaryPort))
		json_set_i_for_key(info, L"primaryPort", primaryPort);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT, &localPort))
		json_set_i_for_key(info, L"localPort", localPort);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &contentLengthDownload))
		json_set_i_for_key(info, L"contentLengthDownload", contentLengthDownload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE, &connectCode))
		json_set_i_for_key(info, L"connectCode", connectCode);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FILETIME, &fileTime))
		json_set_i_for_key(info, L"fileTime", fileTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &totalTime))
		json_set_i_for_key(info, L"totalTime", totalTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE , &requestSize))
		json_set_i_for_key(info, L"requestSize", requestSize);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &headerSize))
		json_set_i_for_key(info, L"headerSize", headerSize);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &speedUpload))
		json_set_i_for_key(info, L"speedUpload", speedUpload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD, &speedDownload))
		json_set_i_for_key(info, L"speedDownload", speedDownload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD, &sizeDownload))
		json_set_i_for_key(info, L"sizeDownload", sizeDownload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &sizeUpload))
		json_set_i_for_key(info, L"sizeUpload", sizeUpload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HTTPAUTH_AVAIL, &httpAuthAvail))
		json_set_i_for_key(info, L"httpAuthAvail", httpAuthAvail);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PROXYAUTH_AVAIL, &proxyAuthAvail))
		json_set_i_for_key(info, L"proxyAuthAvail", proxyAuthAvail);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_OS_ERRNO, &osErrNo))
		json_set_i_for_key(info, L"osErrNo", osErrNo);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &numConnects))
		json_set_i_for_key(info, L"numConnects", numConnects);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &responseCode))
		json_set_i_for_key(info, L"responseCode", responseCode);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME, &nameLookupTime))
		json_set_i_for_key(info, L"nameLookupTime", nameLookupTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &connectTime))
		json_set_i_for_key(info, L"connectTime", connectTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME, &appConnectTime))
		json_set_i_for_key(info, L"appConnectTime", appConnectTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME, &preTransferTime))
		json_set_i_for_key(info, L"preTransferTime", preTransferTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME, &startTransferTime))
		json_set_i_for_key(info, L"startTransferTime", startTransferTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME, &redirectTime))
		json_set_i_for_key(info, L"redirectTime", redirectTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT , &sslVerifyResult))
		json_set_i_for_key(info, L"sslVerifyResult", sslVerifyResult);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &redirectCount))
		json_set_i_for_key(info, L"redirectCount", redirectCount);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &effectiveUrl)))
		json_set_s_for_key(info, L"effectiveUrl", effectiveUrl);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LOCAL_IP, &localIp)))
		json_set_s_for_key(info, L"localIp", localIp);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &contentType)))
		json_set_s_for_key(info, L"contentType", contentType);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP, &primaryIp)))
		json_set_s_for_key(info, L"primaryIp", primaryIp);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &redirectUrl)))
		json_set_s_for_key(info, L"redirectUrl", redirectUrl);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &ftpEntryPath)))
		json_set_s_for_key(info, L"ftpEntryPath", ftpEntryPath);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_SESSION_ID, &rtspSessionId)))
		json_set_s_for_key(info, L"rtspSessionId", rtspSessionId);
	
	json_stringify(info, json, FALSE);

	json_delete(info);
}

void last_path_component(CUTF8String& path)
{
	size_t pos = path.length() -1;
	size_t end = pos;
	size_t len = pos - 1;
	
	for(size_t i = pos; i > 0; --i)
	{
		if((path.compare(i, 1, (const uint8_t *)"/") == 0) && (i == end))
		{
			pos--;len--;continue;
		}
		if(path.compare(i, 1, (const uint8_t *)"/") != 0)
		{
			pos--;continue;
		}
		len++;break;
	}
	
	path = path.substr(pos + 1, len - pos);
}

void remove_trailing_separator(CUTF8String& path)
{
	size_t pos = path.length() -1;
	
	if((path.compare(pos, 1, (const uint8_t *)"/") == 0))
	{
		path = path.substr(0, pos);
	}
	
}

void remove_trailing_separator(CUTF16String& path)
{
	size_t pos = path.length() -1;
	
	if((path.compare(pos, 1, (const PA_Unichar *)L"\\") == 0))
	{
		path = path.substr(0, pos);
	}
	
}

void curl_unescape_path(CURL *curl, CUTF8String& path)
{
	int ftp_path_len = 0;
	char *ftp_path = curl_easy_unescape(curl, (const char *)path.c_str(), path.length(), &ftp_path_len);
	path = CUTF8String((const uint8_t *)ftp_path, ftp_path_len);
	curl_free(ftp_path);
}
